#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

#define IMAGE_BUFLEN 10
#define MAX_HEADER_CHARS 128

#define PPM_MAGIC_NUM 0
#define PPM_UNSIGNED 1
#define PPM_EOF -1
#define PPM_ERROR -2

typedef struct pixel {
  unsigned char r;
  unsigned char g;
  unsigned char b;
} pixel;
  
typedef struct img_info {
  unsigned int height;
  unsigned int width;
  unsigned int new_height;
  unsigned int new_width;
  unsigned int max_color;
  pixel **buff;
  pixel **new_buff;
} img_info;

// this structure is used for parsing the header file
typedef struct token{
  int kind;
  char image[IMAGE_BUFLEN];
  char current_char;
} token;

// contains PPM image information
typedef struct ppm_image_handler {
  img_info imginfo;
  FILE *filep;
  unsigned char* file_buffer;
  char *filename;
  unsigned int filesize;
  unsigned int index_buffer;
  token tkn;
} ppm_image_handler;

token getNextToken(ppm_image_handler *handler);
void getNextChar(ppm_image_handler *handler);
pixel getNextPixel(ppm_image_handler *handler);
void doProcessPPM(ppm_image_handler *handler);
int getImageInfo(ppm_image_handler *handler);
void rotateGrayScaleImage(ppm_image_handler *handler);
void releaseBuffer(ppm_image_handler *handler);

int main(int argc, char **argv) {
  ppm_image_handler handler;
  if (argc != 2) {
    printf("invalid number of arguments: %0d\n", argc);
    printf("ppm_edward <file name>\n");
    exit(-1);
  }
  printf("opening file: %s\n", argv[1]);
  handler.filename = argv[1];
  doProcessPPM(&handler);
  return 0;
}

// rotate and convert image to gray scale
void rotateGrayScaleImage(ppm_image_handler *handler) {
  unsigned int x = 0;
  unsigned int y = 0;

  handler->imginfo.new_height = handler->imginfo.width;
  handler->imginfo.new_width = handler->imginfo.height;

  handler->imginfo.new_buff = (pixel **) malloc(handler->imginfo.new_height * sizeof(pixel *));
  
  for (y = 0; y < handler->imginfo.new_height; y++) {
    handler->imginfo.new_buff[y] = (pixel *) malloc(handler->imginfo.new_width * sizeof(pixel));
  }

  for (y = 0; y < handler->imginfo.height; y++) {
    for (x = 0; x < handler->imginfo.width; x++) {
      unsigned int new_x;
      unsigned int new_y;
      unsigned char new_color;

      new_x = y;
      new_y = handler->imginfo.new_height - x - 1;

      new_color = (handler->imginfo.buff[y][x].r + handler->imginfo.buff[y][x].b + handler->imginfo.buff[y][x].g) / 3;
      handler->imginfo.new_buff[new_y][new_x].r = new_color;
      handler->imginfo.new_buff[new_y][new_x].g = new_color;
      handler->imginfo.new_buff[new_y][new_x].b = new_color;
    }
  }
}

// write output image to file
int putImageToFile(ppm_image_handler *handler) {
  int fileout_size =  strlen(handler->filename) + 5;
  char fileout[MAX_HEADER_CHARS];
  FILE *fofp;
  unsigned int x;
  unsigned int y;
  unsigned int img_sz;

  memset(fileout, '\0', MAX_HEADER_CHARS);
  strncpy(fileout, handler->filename, fileout_size);
  strcat(fileout, ".out");

  img_sz = handler->imginfo.new_width * handler->imginfo.new_height;

  if ((fofp = fopen(fileout, "wb")) == NULL) {
    printf("error here\n");
    return -1;
  }

  fwrite("P6\n", 1, 3, fofp);

  sprintf(fileout, "%s", "# generated by ppm_edward\n");
  fwrite(fileout, 1, strlen(fileout), fofp);

  sprintf(fileout, "%u ", handler->imginfo.new_width);
  fwrite(fileout, 1, strlen(fileout), fofp);

  sprintf(fileout, "%u\n", handler->imginfo.new_height);
  fwrite(fileout, 1, strlen(fileout), fofp);

  sprintf(fileout, "%u\n", handler->imginfo.max_color);
  fwrite(fileout, 1, strlen(fileout), fofp);

  for (y = 0; y < handler->imginfo.new_height; y++) {
    for (x = 0; x < handler->imginfo.new_width; x++) {
      fwrite(&handler->imginfo.new_buff[y][x].r,1, 1, fofp);
      fwrite(&handler->imginfo.new_buff[y][x].g,1, 1, fofp);
      fwrite(&handler->imginfo.new_buff[y][x].b,1, 1, fofp);
    }
  }

  for (y = 0; y < handler->imginfo.new_height; y++) {
    free(handler->imginfo.new_buff[y]);
  }

  free(handler->imginfo.new_buff);
  fclose(fofp);
  return 0;
}

pixel getNextPixel(ppm_image_handler *handler) {
  pixel ret;

  ret.r = handler->file_buffer[handler->index_buffer++];
  ret.g = handler->file_buffer[handler->index_buffer++];
  ret.b = handler->file_buffer[handler->index_buffer++];

  return ret;
}

void getNextChar(ppm_image_handler *handler) {
  if (handler->tkn.current_char == EOF) {
    return;
  }

  if (handler->index_buffer < handler->filesize) {
    handler->tkn.current_char = handler->file_buffer[handler->index_buffer++];
  }
  else {
    handler->tkn.current_char = EOF;
  }

  // ignore comments
  if (handler->tkn.current_char == '#') {
    char next_char;
    do {
      handler->tkn.current_char = handler->file_buffer[handler->index_buffer++];
      next_char = handler->file_buffer[handler->index_buffer];
    } while (handler->tkn.current_char != '\n');
    handler->tkn.current_char = '\n';
  }
}

token getNextToken(ppm_image_handler *handler) {
  // returns error for any invalid token
  handler->tkn.kind = PPM_ERROR;

  // ignore spaces
  while (isspace(handler->tkn.current_char)) {
    getNextChar(handler);
  }

  // if token is a digit
  if (isdigit(handler->tkn.current_char)) {
    int index = 0;
    memset(&(handler->tkn.image), '\0', IMAGE_BUFLEN);
    do {
      handler->tkn.image[index++] = handler->tkn.current_char;
      getNextChar(handler);
    } while (isdigit(handler->tkn.current_char));
    handler->tkn.kind = PPM_UNSIGNED;
  }
  else if (isalpha(handler->tkn.current_char)) { // if token is a word
    int index = 0;
    do {
      handler->tkn.image[index++] = handler->tkn.current_char;
      getNextChar(handler);
    } while (isalnum(handler->tkn.current_char));
    handler->tkn.image[index] = '\0';

    if ((strncmp(handler->tkn.image, "P6", IMAGE_BUFLEN)) == 0) {
      handler->tkn.kind = PPM_MAGIC_NUM;
    }
    getNextChar(handler);
  }

  return handler->tkn;
}

// converts the buffer to 2 dimensional image
int getImageInfo(ppm_image_handler *handler) {
  token current_token;
  unsigned int x;
  unsigned int y;

  // retrieve the magic number
  current_token = getNextToken(handler);
  if (current_token.kind != PPM_MAGIC_NUM) {
    printf("error. invalid file format.\n");
    return -1;
  }

  // retrieve the width
  current_token = getNextToken(handler);
  if (current_token.kind != PPM_UNSIGNED) {
    printf("error. invalid file format.\n");
    return -1;
  }
  handler->imginfo.width = atoi(current_token.image);

  // retrieve the height
  current_token = getNextToken(handler);
  if (current_token.kind != PPM_UNSIGNED) {
    printf("error. invalid file format.\n");
    return -1;
  }
  handler->imginfo.height = atoi(current_token.image);

  // retrieve the maximum color
  current_token = getNextToken(handler);
  if (current_token.kind != PPM_UNSIGNED) {
    printf("error. invalid file format.\n");
    return -1;
  }
  handler->imginfo.max_color = atoi(current_token.image);
  
  handler->imginfo.buff = (pixel **) malloc(handler->imginfo.height * sizeof(pixel *));
  
  for (y = 0; y < handler->imginfo.height; y++) {
    handler->imginfo.buff[y] = (pixel *) malloc(handler->imginfo.width * sizeof(pixel));
    for (x = 0; x < handler->imginfo.width; x++) {
      handler->imginfo.buff[y][x] = getNextPixel(handler);
    }
  }

  if (handler->filesize != handler->index_buffer) {
    printf("file format error\n");
  }

  return 0;
}

void releaseBuffer(ppm_image_handler *handler) {
  unsigned int y;
  for (y = 0; y < handler->imginfo.height; y++) {
    free(handler->imginfo.buff[y]);
  }
  free(handler->imginfo.buff);
}

void doProcessPPM(ppm_image_handler *handler) {
  // initialize ppm_image_handler
  handler->filep = fopen(handler->filename, "rb");
  if (handler->filep == NULL) {
    printf("error here. opening file\n");
    return;
  }

  if (fseek(handler->filep , 0 , SEEK_END) < 0) {
    printf("error here. fseeking file\n");
    return;
  }
    
  // get file size and allocate buffer for the whole file
  handler->filesize = ftell(handler->filep);
  rewind(handler->filep);
  handler->file_buffer = (unsigned char*) malloc(sizeof(unsigned char) * handler->filesize);
  fread(handler->file_buffer, 1, handler->filesize, handler->filep);

  // initialize variables for parsing
  handler->index_buffer = 0;
  handler->tkn.current_char = '\n';

  // get header file information
  if (getImageInfo(handler) != 0) {
    goto exit;
  }
  
  // process the image
  rotateGrayScaleImage(handler);

  // write the processed image to file
  if (putImageToFile(handler) != 0) {
    goto exit;
  }

  releaseBuffer(handler);

  exit:
  // release allocated image buffer
  free(handler->file_buffer);
  fclose(handler->filep);
}
